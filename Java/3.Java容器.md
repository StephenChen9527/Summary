# 容器

容器是Java中最重要的一个东西。

一般有以下几个：

1. List：有序，可重复
2. Set：无序，不可重复
3. Map：K-V形式，key是不可重复，且是无序的，但是其中的具体实现可以实现有序（插入顺序或Key的自然排序）
4. Queue：队列，先进先出



## List

List主要有两大实现：`ArrayList`和`LinkedList`

* ArrayList

底层数据结构是数组，可动态扩容，当插入数组的尾部，可以直接放入（如果数组有空余空间），如果插入数组的中间部分，则会引起位置后的元素的移动（删除也是）；由于数组的尾部可能没有放满元素，因此有一定的空间浪费；而且由于是数组，会需要连续的内存空间



扩容：ArrayList每次插入新元素的时候，会先判断当前的数组长度是否足够，如果不够，则进行扩容；扩容也会导致数组的复制，扩容后的数组是原始数组长度的`1.5`倍。

数组的默认长度是10。



寻址的时间复杂度O(1)（可通过下表进行寻址），插入的复杂度：O(N-i)，因为需要移动`n-i`个元素



* LinkedList

底层数组是链表，不管是插入尾部，还是中间，都不会引起数组的移动，因为两个元素是通过`next`属性维护的，但是需要程序从前到尾进行遍历，查找到合适的位置；由于链表维护了后一个节点的位置，因此会多占用一些内存空间；但是在插入过程中，直接修改`next`属性，因此时间复杂度是O(1)，但是需要遍历链表，才能查找到插入的位置，遍历链表的时间复杂度是O(N)。



两者都是线程不安全的类。



## Set

Set的主要实现类有：`HashSet`、`TreeSet`、`LinkedHashSet`，集合主要用来做除重或者去做交叉并补比较方便。

* HashSet

底层是基于`HashMap`完成的，具体结构请移步`HashMap`；该集合是一个无序的，不保障插入顺序

* TreeSet

底层的数据结构是`红黑树`，由于树的性质，因此该集合是一个可以排序的集合，一般情况下，按照自然排序，可以传入一个，比较器`Comparator`或者存储的对象实现`Comparable`接口，进行排序。

* LinkedHashSet

内部是通过 `LinkedHashMap` 来实现的



## Map



Map的主要实现类有：`HashMap`、`TreeMap`、`LinkedHashMap`、`HashTable`



* HashTable：底层数据结构是 数组+链表 ，是一个线程安全的K-V集合，但是由于是通过锁住当前整个集合，会导致集合的性能较低。不能存储K-V为`null`的对象。
* LinkedHasMap：`LinkedHashMap` 继承自 `HashMap`，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，`LinkedHashMap` 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
* TreeMap： 红黑树（自平衡的排序二叉树）

* HashMap：该Map是最常用，也是内容最多的Map。

### HashMap与HashTable

1. **线程是否安全：** `HashMap` 是非线程安全的，`HashTable` 是线程安全的。
2. **效率：** 因为线程安全的问题，`HashMap` 要比 `HashTable` 效率高一点。另外，`HashTable` 基本被淘汰，不要在代码中使用它；
3. **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value；HashTable 不允许有 null 键和 null 值。
4. **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证，下面给出了源代码）。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。
5. **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。



### HashMap详解

由于1.7与1.8变动，有以下不同：

底层数据结构：1.7是数组+链表实现；1.8则是引入了红黑树，当链表的长度大于8的时候（且数组长度大于64，如果不大于64，则优先扩容数组），会转化为红黑树，当红黑树节点减少到6个的时候，会退化成为链表。

