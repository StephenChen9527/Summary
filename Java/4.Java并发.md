# 并发

## 进程与线程

进程是程序的一次执行过程，是系统运行程序的基本单位。

线程则是最小的资源调度单位，一个进程可以由多个线程组成。



## Java中的多线程

Java中实现多线程的形式：

1. 继承`Tread`类，重写`run`方法
2. 实现`Runnable`，实现`run`方法
3. 实现`Callable` 接口
4. 通过`线程池`

```txt
争议：
		个人觉得实现多线程的方法只有通过Tread类去做，无论2、3、4其实都是需要通过Tread去完成新线程的启动，其他博主的博文有的说2种（1、2，个人比较赞同），有人说3种（1、2、3或者1、2、4）。
```



由于Java是通过本地方法去启动一个新线程的，虽然重写的是`run`方法，但是还是要通过`start`方法启动，直接run并不能启动新的线程。



## 线程的状态

1. `NEW`：初始状态，线程被实例化出来后，暂未调用start方法
2. `READY/RUNNABLE`：就绪状态，当实例线程调用start方法后，除CPU外，其他资源均就绪
3. `RUNNING`：运行状态，当线程获得CPU的执行权，进入运行状态，不过通常把2与3统称为：运行状态
4. `BLOCKED`：阻塞状态，当线程等待获取锁或者进入IO等待的时候，就是阻塞状态
5. `WAITING`：等待状态，一般是调用`wait`方法
6. `TIME_WAITING`：超时等待，一般是调用`sleep(long)`、`wait(long)`
7. `TERMINATED`：终止状态：线程执行完毕或者异常终止。



![Java 线程状态变迁 ](images/Java+%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png)



### wait与sleep的区别

- 两者最主要的区别在于：**`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- 两者都可以暂停线程的执行。
- `wait()` 通常被用于线程间交互/通信，`sleep() `通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify() `或者 `notifyAll()` 方法。`sleep() `方法执行完成后，线程会自动苏醒。或者可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()`是`Object`中的方法，而`wait()`是`Thread`中的方法



## 多线程带来的麻烦

### 上下文切换带来的开销

CPU一般通过`时间片轮转`的方式，在一秒内，通过切换N个线程来进行让操作近似于同时在运行，但CPU核心在某一瞬间，还是只执行一个线程，因此就需要进行线程切换，切换的来回要保证现场（下次再执行的时候，需要知道执行到某处），这里就涉及到保存上下文。



**任务从保存到再加载的过程就是一次上下文切换**



### 共享资源的问题

当有多个线程共同访问同一个资源的时候，由于先后顺序，会产生不可预料的问题，因此需要对资源进行互斥处理，同一时刻，只能有同一个线程去访问，因此产生了“锁”的概念。



### 死锁

线程死锁的描述：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

![线程死锁示意图 ](images/2019-4%E6%AD%BB%E9%94%811.png)

死锁一般有4个必要条件

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。



如何避免死锁？只需要打破4个必要条件即可，但是互斥是无法打破的，

1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
2. **破坏请求与保持条件** ：一次性申请所有的资源。
3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。



### 多线程环境下的不可见性

由于JMM的规定，每个线程都有自身的工作空间，一般再操作共享变量的时候，会先Copy一份副本到自己的工作空间中，访问变量也会优先访问工作空间内的变量，当如果修改的话，也会先修改工作空间的值，然后再刷新到主内存里面。

正是由于每个线程都有私有空间，因此其他线程对共享变量进行修改之后，其他线程“看不到”改变后的值，因此会有一个不可见的问题。



## 线程池

线程池是一个池化技术，主要是为了减少每次获取资源的消耗，提高对资源的利用率。

线程池主要是Executor框架。

线程池的主要构成：

1. 任务
2. 任务的执行(Executor)
3. 异步结果(Future)



### 自定义线程池

```java
public ThreadPoolExecutor(int corePoolSize,//线程池的核心线程数量
                              int maximumPoolSize,//线程池的最大线程数
                              long keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,//时间单位
                              BlockingQueue<Runnable> workQueue,//任务队列，用来储存等待执行任务的队列
                              ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可
                              RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
                               )
```



参数意义：

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

* **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；

* **`unit`** : `keepAliveTime` 参数的时间单位。

* **`threadFactory`** :executor 创建新线程的时候会用到。

* **`handler`** :拒绝策略。



### 拒绝策略

- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来拒绝新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`**：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。



### 阻塞队列

补充到JUC模块



### 线程的工作流程

线程池初始化之后，并不会立马创建线程，而是会等待任务到的时候，去创建线程，是一个懒加载的思想。



假设：核心线程数 = 5 ，最大线程数 = 10 ， 队列使用有界队列，长度是10，描述一下任务加入的过程。

1. 当任务加入的时候，会先判断是否已经到达核心线程数，如果没有，则优先创建线程。
2. 如果已经创建足够的核心线程数，则判断队列是否放满，如果没有满，则放入队列中等待。
3. 如果队列满了，则判断是否到达最大线程数，如果没有则创建线程。
4. 如果队列满了，且核心线程数也满了，则会触发拒绝策略。
5. 当任务队列中没有任务，则线程会等待到等待时间，然后销毁，直到线程数等于核心线程数，但是销毁哪些线程不是固定的，不是后生成的线程就销毁，完全是随机的。



等待销毁的过程主要是在阻塞队列上面进行了超时等待，等待足够长的时间，以后，还是获取为null的话，就会继续循环，进行CAS的方式进行销毁某个线程，直到线程减少到核心线程数

```java
Runnable r = timed ?
                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                    workQueue.take();
```





![图解线程池实现原理](images/图解线程池实现原理.png)



### 几类常见的线程池：

1. 

